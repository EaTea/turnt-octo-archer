\section{Software Process Representations} \label{diagrams}

In the following section, we use our notation to depict 

\subsection{Software Development Lifecycle (SDLC) and its variants}
Royce first introduced and formalised the SDLC in
\cite{Royce:1987:MDL:41765.41801}.
He was quick to criticise the SDLC as a software development methodology, and pointed out its flaws
and inflexibility to handle software development.
In particular, he noted that its roots were in engineering and other physicals sciences, and the
nature of software meant that it was ineffective and caused much work to be redundantly repeated.\\
\\
This model is commonly known as a ``Waterfall" lifecycle development model, due to the way
activities cascaded in the original model.
We reproduce his diagrams in our own notation as follows.
In Figure \ref{waterfallRoyceOne}, we show our interpretation of Royce's unmodified waterfall model.

\begin{figure}[ht!]
	\centering
	\includegraphics[scale=0.3]{media/WaterfallRoyceOne}
	\caption{Royce's original waterfall model. This is the theoretical way that
    the SDLC works. There is the implicit assumption that ``testing" is a proof
      of correctness, not an exercise to find defects, and it is automatically
      going to be correct. We shall refer to this model as Waterfall-1.}
	\label{waterfallRoyceOne}
\end{figure}

Royce points out the flaws in this model, by revealing that we actually make mistakes and
assumptions when we gather requirements, design a system or implement a system in code.
These assumptions are actually defects that propagate throughout a system, and we are forced to
backtrack to earlier tasks and repeat these tasks in order to fix them.
This can involve backtracking from implementing a feature, to checking how it was designed, to
regathering requirements for this feature upon realising that a client does not actually need that
feature.
Royce claimed this backtracking was quite a significant delay and waste of resources, and we
illustrate his point in our notation in Figure \ref{waterfallRoyceTwo}.

\begin{figure}[ht!]
	\centering
	\includegraphics[scale=0.3]{media/WaterfallRoyceTwo}
	\caption{Royce claims that this modified waterfall method was inefficient and caused unnecessary
		backtracking, but that in 1987 it was the current mode of software
      production. We shall refer to this as Waterfall-2.}
	\label{waterfallRoyceTwo}
\end{figure}

Royce suggests an alternative model, which involves iterations and backtracking between stages to
minimise the repeated work.
This recognition that some sort of iteration is necessary to develop good software is perhaps the
beginning of some of the iterative models that we later discuss.
We show Royce's final model in our own notation in \ref{waterfallRoyceThree}, with a heavy emphasis
on verification between each stage to dictate the backtracking.

\pagebreak

\begin{figure}
	\centering
	\includegraphics[angle=90,scale=0.3]{media/WaterfallRoyceThree}
	\caption{Royce's final waterfall model resolves the repetition in process work by increasing the
		verification and iteration between stages. We replicate this in our own
      notation. This model shall be referred to as Waterfall-3.}
	\label{waterfallRoyceThree}
\end{figure}

\subsection{Spiral}
The Spiral model is introduced by Boehm in \cite{Boehm:1986:SMS:12944.12948}.
It attempts to address some of the weaknesses revealed in SDLC.
It has more concepts of verification and risk analysis built into it.
We show the Spiral model, after it has been unrolled from its original form, in Figure
\ref{Spiral}.\\
\\

\begin{figure}
	\centering
	\includegraphics[scale=0.3]{media/Spiral}
	\caption{Barry Boehm's spiral model. We note that it is quite similar to Figure
		\ref{waterfallRoyceThree}.}
	\label{Spiral}
\end{figure}

In reality, this model is actually the SDLC, with more specifications, more risk analysis, and
in \cite{Boehm:1986:SMS:12944.12948} it is rolled up in a spiralling shape.
This does not change that it is really the SDLC waterfall model.
Furthermore, it is unclear in the initial paper what verification is, or where the process should go
back to when a verification point fails.
This is a weakness of the Spiral model, and the Waterfall models as well, though Boehm is more
explicit as to where backtracking should lead to when a defect is uncovered.\\
\\
The spiral model does not represent a significant shift in industry mindset and indeed, we note that
it still ascribes to the ``single stage, verifiy that everything is correct, move onto next stage"
mindset that early industry had.

\subsection{V-Model}

We note that the V-Model is perhaps one of the last of the Waterfall-esque models.
It is introduced by Fosberg et. al in \cite{forsberg1995relationship}.
Again, we note its roots in systems and ``traditional" engineering, where a stage-by-stage based
approach is taken.
Its main difference is perhaps the large amount of preparation and planning to construct plans for
verification.
These plans are constructed before project implementation, and the explicit highlighting of this
construction distinguishes SLDC from the V-model.
We show the V-Model within our notation in Figure \ref{VModel}.

\begin{figure}
	\centering
	\includegraphics[scale=0.3]{media/VModel}
	\caption{The V-Model, as represented within our notation. Due to its many verification construction stages it is quite an extensive
		model within our notation. One might comment that it is a weakness of our notation that some
			models have become extremely large.}
	\label{VModel}
\end{figure}

\pagebreak

\subsection{Rapid Prototyping}
Rapid prototyping, as was specified in \cite{Alavi:1984:APA:358080.358095}, is a process
specifically concerned with requirements gathering.
It constructs small prototypes that are mockups of the final system to assist in understanding a
client's requirements.
As a result, we will make two simplifications for our modelling of the rapid prototyping process.
\begin{enumerate}
	\item the process only changes requirements gathering, and other processes remain the same
	\item we need only model requirements gathering process, up to the generation of a requirements
	analysis document to show how rapid prototyping works
\end{enumerate}

Based on these assumptions, we show Rapid Prototyping in our own notation --- see Figure
\ref{RapidProto}. We note that this methodology would be ineffective in the case that building a prototype would be very
inexpensive or a user might not have much interaction with the system.

\begin{figure}
	\centering
	\includegraphics[scale=0.4]{media/RapidPrototyping}
	\caption{Rapid prototyping is shown above, only being used in the requirements gathering stage.
		This is also known as ``throwaway prototyping", due to the prototype being used onl in
			requirements gathering, but not in production code.}
	\label{RapidProto}
\end{figure}


\subsection{Incremental}
In \cite{pressman1992software}, Pressman suggests that an iterative, or incremental application of the
Waterfall model would be a way to offset the problems in software.
It is difficult to see much value in this mode of thinking, since it is not fine-grained enough or flexible
enough to truly make use of iteration.
It is worthwhile noting that it is difficult to see when it is appropriate to stop building or
iterating.
We provide an interpretation of this model in our own notation in Figure \ref{IncrementalFig}.

\begin{figure}
	\centering
	\includegraphics[scale=0.3]{media/Incremental}
	\caption{The incremental model. Our references have suggested it is merely a Waterfall model being
		applied iteratively to small chunks and we have modelled it as such.}
	\label{IncrementalFig}
\end{figure}

\subsection{Evolutionary}

We refer to the lecture given by Woodings, when we discuss Tom Gilb's evolutionary paradigm
\cite{Woodings2013Lecture2}.
In it, Woodings discusses the idea of building a house using the evolutionary paradigm, and of growing
software.
We also refer to \cite{gilb1999evolutionary} to outline the evolutionary
process.
Within it, we see an iterative, user-focused method of growing software based on
user interactions.
``Fit" goals which are high priority for users are implemented first, and a
focus on quickly delivering value and gathering user feedback in each
implementation phase is evident.
This is a step away from Incremental, or the other Waterfall-based methods and
perhaps is the first true precursor to agile methods.
We show our notation of Evolutionary development in Figure \ref{Evolution}.

\begin{figure}
\centering
\includegraphics[scale=0.4]{media/Evolution}
\caption{The Evolutionary process. Note the similarities to Scrum, the focus on
user development and the eschewing of ``traditional" phase-based engineering
  that Royce and the SDLC suggested.}
\label{Evolution}

\end{figure}

\subsection{Extreme Programming}
Extreme programming was first developed by Beck, and formalised in \cite{beck2004extreme}.
It is an extremely streamlined process emphasising a lot of feedback loops, and a quick turnaround.
It is noteworthy that we have come across an aspect of the process that we cannot communicate;
namely, the timely and short manner in which Extreme Programming goes about its tasks.
Beck highlights pair coding, clear communication and a quick delivery and release time as key
attributes of the extreme programming software methodology.
We outline it below in Figure \ref{WindowsXP}.

\begin{figure}
	\centering
	\includegraphics[scale=0.3]{media/EXP}
	\caption{The Extreme Programming methodology focuses on quick, constant feedback and short
		iterations.}
	\label{WindowsXP}
\end{figure}

\subsection{Crystal Clear}
Crystal Clear was introduced by Cockburn in \cite{cockburn2004crystal}.
He constructs a small-team methodology that particularly focuses on
\begin{itemize}
	\item frequent delivery
	\item reflective improvement
	\item osmotic communication
\end{itemize}

It stresses user involvement in the development process and has a somewhat happy union of advantages
that SDLC offers with the development process of Scrum, but with a more light-weight version of the
documentation-heavy SDLC.
We present in Figure \ref{CrystalClean} the Crystal Process in our notation.

\begin{figure}
	\centering
	\includegraphics[scale=0.3]{media/Crystal}
	\caption{The Crystal Clear process is interesting in that it also recommends a point where the
		methodology dictates exiting and cancelling a project. This is not so clear in the other
			methodologies, and is instead implicit.}
	\label{CrystalClean}
\end{figure}

\subsection{Test-Driven Development}

Test-Driven Development was introduced and formalised by Beck in \cite{Beck:2002:TDD:579193}.
It is an interesting method that is localised to the development stages.
Primarily, it advocates writing a test and having it fail before writing the code itself.
We make the following two assumptions:
\begin{itemize}
	\item test-driven development does not influence any other tasks besides development and testing
	\item test-driven development can be fully modelled by simply looking at the development stage
\end{itemize}

We show Test-Driven Development in Figure \ref{TDD} using our notation.

\begin{figure}
	\centering
	\includegraphics[scale=0.35]{media/TDD}
	\caption{Test-Driven Development is a simple method of specifying the testing strategy first, then
		the development afterwards.}
	\label{TDD}
\end{figure}

\subsection{Scrum}
The Scrum model was first introduced by Takeuchi and Nonaka in \cite{takeuchi1986new}.
This is a much more agile-like process, without as many sequential steps and many more iterative
loops and decision points.
It eschews documentation and analysis for coding and continuous design.
This would be appropriate for user-facing software that an engineer or development team is already
familiar in coding or working with.
We show a representation of the Scrum process in our own notation in Figure \ref{ScrumFig}.

\begin{figure}[ht!]
	\centering
	\includegraphics[scale=0.3]{media/Scrum}
	\caption{Scrum is a development model for software, and here we can see the feedback and
		simplified, easy-to-understand and responsive process that Scrum employs.}
	\label{ScrumFig}
\end{figure}

\subsection{My Process}
I also document my own process.
It bears some resemblance to Crystal Clear, but is tailored for a single-developer project where
requirements are easily understood and external verification is possible.
It concentrates on maintaining documentation so that another developer could easily join or take
over the project.\\
\\
This process was the one I developed and used within Google as an intern whilst
working on specific features of a product.
It was designed to leave a good paper trail and accountability/tracking of my
work and project.
In a team environment, I would prefer to use a Scrum-like methodology or Crystal Clear pseudo-method
to encourage clear communication within the team.
My process is denoted in Figure \ref{MyProcess}.

\begin{figure}
	\centering
	\includegraphics[scale=0.3]{media/MyProcess}
	\caption{My process; in particular, note the heavy emphasis on updating documentation of the
		project to match actual project state, and the need to ensure client input at every round of
			input. Furthermore, the similar idea from Scrum and Crystal Clear --- that the client is
			delivered working code on a timely, continuous basis.}
	\label{MyProcess}
\end{figure}
