\section{Software Process Notation --- TODO by 0000 13th August 2013} \label{notation}

In Section \ref{introduction}, we briefly discussed the idea of classifying and comparing models.
As we further noted, the different process descriptions make classification and comparison of
development processes difficult.
Thus, we introduce a standardised notation that will allow us to describe and discuss software
processes in an unambiguous manner.\\
\\
To a reader interested in the notation used throughout the paper, we direct them
to \FIXME which summarises the graphical and formal language notations we have
designed.
It gives the natural language meaning and semantics of each of the symbols and
pseudo-code constructs we employ.\\
\\
Otherwise, this chapter introduces our graphical notation by justifying each symbol we
use.
We draw inspiration from UML Activity Diagrams \cite{Dumas01umlactivity,BellUMLBasics}, as well as
the notation Woodings describes in \ref{Woodings2013Tut1}.
We discuss the design and ideas behind our notation, and why we believe it is a
good notation system.
Finally, we motivate a formal pseudo-code style notation that is (approximately)
  equivalent to our graphical notation.

\subsection{Notation}

In \cite{fuggetta2000software} we define a process as
\begin{quote}
A software process can be defined as the coherent set of policies, organizational structures,
	technologies, procedures, and artifacts that are needed to conceive, develop, deploy, and maintain
	a software product.
\end{quote}

From this definition, we can note that we must be able to at least denote four things
\begin{itemize}
	\item a point at which the set of policies and technologies should begin deployment
	\item a point at which the policies and technologies should cease operation on the software
	product development
	\item sub-tasks to arbitrarily divide the component procedures of a process into as fine detail as
	is necessary
	\item inputs and outputs which are the artifacts used within a software development process
\end{itemize}

We first introduce the entry and exit points of a process; these are the points where it starts and
ends.

\begin{figure}[h!]
\centering
\begin{subfigure}[b]{.45\textwidth}
\centering
\includegraphics[scale=0.6]{media/Entry}
\caption{The entry point in the program.}
\label{entryFigure}
\end{subfigure}
~
\begin{subfigure}[b]{.45\textwidth}
\centering
\includegraphics[scale=0.6]{media/Exit}
\caption{The exit point of the program.}
\label{exitFigure}
\end{subfigure}
\caption{Here, we show our notation for the entry and exit points of a process.
Note that it is quite similar to notation in \ref{Dumas01umlactivity} for
  signifying where a process begins and ends.}
\label{entryExitFigure}
\end{figure}

Without knowing where we start and end, our process is a never-ending sequence of tasks, which
either has no recognisable place to start or no point to recognise the software product as
``finished".
This is counter-intuitive to the purpose of a process which is to construct a software product.\\
\\
Next, we define a sub-task.
As we noted in our previous definition, there are sub-procedures which make up our process.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.6]{media/Task}
\caption{A single task of a process.}
\label{taskFigure}
\end{figure}

In \cite{Woodings2013Tut1}, Woodings comments on the need to break down a
process into tasks.
A process that consists of a single task is pointless, as it offers no new
insights into the innards and comparability of a process.\\
\\
Thus, a single task must act on {\em something}, and as a result of its actions
it must produce something different.
To denote dependencies upon inputs or other tasks, we use arrows, whilst we denote tangible outputs
from a task with a circle.

\begin{figure}[h!]
\centering
\begin{subfigure}[b]{.45\textwidth}
\centering
\includegraphics[scale=0.6]{media/Dependency}
\caption{The arrow denotes a dependency of one task on another. As an example, suppose $A \to B$.
	Then $B$ is dependent on $A$.}
\label{depFigure}
\end{subfigure}
~
\begin{subfigure}[b]{.45\textwidth}
\centering
\includegraphics[scale=0.6]{media/Output}
\caption{This circle denotes the output from a task, but also the input to another task. It
is logical that each output is used as the input of {\em some} point in the process (including the
		exit point), otherwise the output itself has no usage.}
\label{outputFigure}
\end{subfigure}
\caption{An arrow will show dependency and a circle shows the output of a task,
which also denotes the input for some point in the process.} \label{depOutFigure}
\end{figure}

Note that we have said that \ref{outputFigure} denotes either an input or an
output.
We note that although an output must implicitly be an output to some other
process point, inputs need not necessarily be generated from a task.
Similarly, we do not make the claim that all tasks require inputs, only that
they must generate some output.\\
\\
Processes may branch at certain points due to needing to make a decision on the conditions of the
process and the appropriate path the process should take to complete development.
We will call these ``decision points".
At other times, tasks can be parallelised between members of the software development team.

\begin{figure}[h!]
\centering
\begin{subfigure}[b]{.45\textwidth}
\centering
\includegraphics[scale=0.6]{media/Parallelised}
\caption{The above notation symbolises that multiple tasks should begin occurring in parallel (that
		is, simultaneously).}
\label{parFigure}
\end{subfigure}
~
\begin{subfigure}[b]{.45\textwidth}
\centering
\includegraphics[scale=0.6]{media/Branching}
\caption{The following is a decision point, where multiple paths can emerge from this single point.}
\label{branFigure}
\end{subfigure}
\end{figure}

\pagebreak %TODO: Check if pagebreak is good idea

Finally, we pay a special attention to the verification process.
Verification that a task is correct and its outputs meet the requirements and standards expected by a client
and other software maintainers is, in itself a process.
We separate our notation of verification to thus distinguish it as a ``shadow" or ``reflection"
procedure of a task (or sequence of tasks).

\begin{figure}[h!]
\centering
\begin{subfigure}[b]{.45\textwidth}
\centering
\includegraphics[scale=0.6]{media/BeginVerification}
\end{subfigure}
~
\begin{subfigure}[b]{.45\textwidth}
\centering
\includegraphics[scale=0.6]{media/EndVerification}
\end{subfigure}
\caption{Here, verification is treated as its own subprocess. The notation has the same meaning as
	\ref{taskFigure} or \ref{branFigure}, except restricted to the verification process.
	However, its dotted-line distinction is
	two-fold; it is the ``shadow" process to ensure that a task has been completed correctly, but is
		also treated in an ad-hoc and almost ``optional" manner by organisations.
		Thus it is not a ``solid" or ``defined" process like \ref{taskFigure} or \ref{branFigure}.}
\label{verification}
\end{figure}

\subsection{Design}

\begin{itemize}
	\item what makes a notation good
	\item why did I choose this specific notation
\end{itemize}

\subsection{Programming Translation}

\subsection{Summary}

Big table of stuff.
