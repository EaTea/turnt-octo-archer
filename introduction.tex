\chapter{Introduction}

\begin{quote}
Software inspection is a method of static testing to verify that software meets
its requirements.
$\ldots$
Users of the method report very significant improvements in quality that are
accompanied by lower costs and greatly reduced maintenance efforts.
Excellent results have been obtained by small and large organizations in all
aspects of new development as well as in maintenance.
$\ldots$ developers who participate in the inspection of their own product
create fewer defects in future work.
\end{quote}

Michael Fagan \cite{AdvancesInSoftwareInspection} makes these bold claims of a
software verification method to trump all others in his seminal review of {\em
  software inspections}, or {\em code reviews}.
His review, {\it Advances in Software Inspections}, provides a broad overview of
literature discussing code reviews.
It argues that code reviews will, in no uncertain terms, improve the quality,
   cost, schedule and maintenance of software projects.\\
\\
Fagan's work, although far-reaching and (in my opinion) influential, is also
dated.
A work from 1986 can hardly be said to be ``modern", and its impact and
relatedness to today's software development industry has been greatly reduced.
New defect detection techniques and ideas, such as extreme programming,
test-driven development, red-green refactoring and automated static
inspection have greatly changed the defect detection and prevention
environment.\\
\\
Within this paper, we aim to update Fagan's seminal work with our own
far-reaching review of software inspections.
We will compare software inspections to new methods of defect prevention and
detection, and argue for the relevance and usefulness of software inspections.
In addition, we shall discuss the improvements that have been made to software
inspections.
We will aim to highlight the unanswered questions that revolve around code
reviews and propose a series of experiments that could be performed to
contribute to answering these questions.\\
\\
This paper is arranged as follows:
\begin{itemize}
  \item Chapter \ref{chapter:defects} defines defects as in literature, gives
  our own definition 
  \item Chapter \ref{chap:otherdets} discusses a range of newer defect detection
  and prevention techniques, besides code reviews
  \item Chapter \ref{chap:litsurvey} gives the main results of our review, with
  an examiniation of the merits of reviews in general, the benefits and
  negatives of code reviews and the open questions we have found in reviewing
  the state of the art
  \item Chapter \ref{chapter:experiment} discusses a series of experiments to
  contribute toward answering these open questions
\end{itemize}

% Here we motivate the problem from scratch. Usually a concrete
% example will do this well. The first paragraph sets the scene
% and states the problem explicitly. It sets up the second paragraph,
% which will state explicitly your hypothesis for solving it.
% 
% Now comes a short, sharp and succinct exposition of your approach.
% For example, ``It thus seems reasonable to conjecture that a
% combination of the X algorithm and the Y algorithm would produce
% superior results to either algorithm on its own. We show that this is
% indeed the case, and prove that the combined algorithm has complexity,
% on the average, that is an order of magnitude better than either the X
% or the Y algorithm.''
% 
% Then there is a bit more motivation, linking the problem to other
% researchers, but not in detail. You also talk in a general way about
% the methodology you have employed to solve the problem.
% 
% The final paragraph should give the conclusions of your
% paper. Something like ``We conclude that the combined X-Y algorithm is
% better suited to robot control problems than either the X algorithm or
% the Y algorithm'' would be appropriate.
